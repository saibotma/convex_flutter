// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'convex/base_client.dart';
import 'convex/client.dart';
import 'convex/client/subscription.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `WebSocketState`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvexClient>>
abstract class ConvexClient implements RustOpaqueInterface {
  /// Perform an action `name` with `args` and return a future
  /// containing the return value of the action once it completes.
  ///
  /// ```no_run
  /// # use convex::ConvexClient;
  /// # use futures::StreamExt;
  /// # #[tokio::main]
  /// # async fn main() -> anyhow::Result<()> {
  /// let mut client = ConvexClient::new("https://cool-music-123.convex.cloud").await?;
  /// let result = client.action("sendGif", maplit::btreemap!{
  ///     "body".into() => "Tatooine Sunrise.".into(),
  ///     "author".into() => "Luke Skywalker".into(),
  /// }).await?;
  /// println!("{result:?}");
  /// # Ok(())
  /// # }
  Future<FunctionResult> action({
    required String name,
    required BTreeMapStringValue args,
  });

  /// Perform a mutation `name` with `args` and return a future
  /// containing the return value of the mutation once it completes.
  ///
  /// ```no_run
  /// # use convex::ConvexClient;
  /// # use futures::StreamExt;
  /// # #[tokio::main]
  /// # async fn main() -> anyhow::Result<()> {
  /// let mut client = ConvexClient::new("https://cool-music-123.convex.cloud").await?;
  /// let result = client.mutation("sendMessage", maplit::btreemap!{
  ///     "body".into() => "Let it be.".into(),
  ///     "author".into() => "The Beatles".into(),
  /// }).await?;
  /// println!("{result:?}");
  /// # Ok(())
  /// # }
  Future<FunctionResult> mutation({
    required String name,
    required BTreeMapStringValue args,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Constructs a new client for communicating with `deployment_url`.
  ///
  /// ```no_run
  /// # use convex::ConvexClient;
  /// # #[tokio::main]
  /// # async fn main() -> anyhow::Result<()> {
  /// let client = ConvexClient::new("https://cool-music-123.convex.cloud").await?;
  /// # Ok(())
  /// # }
  /// ```
  static Future<ConvexClient> newInstance({required String deploymentUrl}) =>
      RustLib.instance.api.convexConvexClientNew(deploymentUrl: deploymentUrl);

  static Future<ConvexClient> newFromBuilder({
    required ConvexClientBuilder builder,
  }) => RustLib.instance.api.convexConvexClientNewFromBuilder(builder: builder);

  /// Make a oneshot request to a query `name` with `args`.
  ///
  /// Returns a [`FunctionResult`] representing the result of the query.
  ///
  /// This method is syntactic sugar for waiting for a single result on
  /// a subscription.
  /// It is equivalent to `client.subscribe(name,
  /// args).await?.next().unwrap()`
  ///
  /// ```no_run
  /// # use convex::ConvexClient;
  /// # use futures::StreamExt;
  /// # #[tokio::main]
  /// # async fn main() -> anyhow::Result<()> {
  /// let mut client = ConvexClient::new("https://cool-music-123.convex.cloud").await?;
  /// let result = client.query("listMessages", maplit::btreemap!{}).await?;
  /// println!("{result:?}");
  /// # Ok(())
  /// # }
  Future<FunctionResult> query({
    required String name,
    required BTreeMapStringValue args,
  });

  /// Set admin auth for use when calling Convex functions as a deployment
  /// admin. Not typically required.
  ///
  /// You can get a deploy_key from the Convex dashboard's deployment settings
  /// page. Deployment admins can act as users as part of their
  /// development flow to see how a function would act.
  Future<void> setAdminAuth({
    required String deployKey,
    UserIdentityAttributes? actingAs,
  });

  /// Set auth for use when calling Convex functions.
  ///
  /// Set it with a token that you get from your auth provider via their login
  /// flow. If `None` is passed as the token, then auth is unset (logging
  /// out).
  Future<void> setAuth({String? token});

  /// Subscribe to the results of query `name` called with `args`.
  ///
  /// Returns a [`QuerySubscription`] which implements [`Stream`]<
  /// [`FunctionResult`]>. A new value appears on the stream each
  /// time the query function produces a new result.
  ///
  /// The subscription is automatically unsubscribed when it is dropped.
  ///
  /// ```no_run
  /// # use convex::ConvexClient;
  /// # use futures::StreamExt;
  /// # #[tokio::main]
  /// # async fn main() -> anyhow::Result<()> {
  /// let mut client = ConvexClient::new("https://cool-music-123.convex.cloud").await?;
  /// let mut sub = client.subscribe("listMessages", maplit::btreemap!{}).await?;
  /// while let Some(result) = sub.next().await {
  ///     println!("{result:?}");
  /// }
  /// # Ok(())
  /// # }
  Future<QuerySubscription> subscribe({
    required String name,
    required BTreeMapStringValue args,
  });

  /// Get a consistent view of the results of multiple queries (query set).
  ///
  /// Returns a [`QuerySetSubscription`] which
  /// implements [`Stream`]<[`QueryResults`]>.
  /// Each item in the stream contains a consistent view
  /// of the results of all the queries in the query set.
  ///
  /// Queries can be added to the query set via [`ConvexClient::subscribe`].
  /// Queries can be removed from the query set via dropping the
  /// [`QuerySubscription`] token returned by [`ConvexClient::subscribe`].
  ///
  ///
  /// [`QueryResults`] is a copy-on-write mapping from [`SubscriberId`] to
  /// its latest result [`Value`].
  ///
  /// ```no_run
  /// # use convex::ConvexClient;
  /// # use futures::StreamExt;
  /// # #[tokio::main]
  /// # async fn main() -> anyhow::Result<()> {
  /// let mut client = ConvexClient::new("https://cool-music-123.convex.cloud").await?;
  /// let mut watch = client.watch_all();
  /// let sub1 = client.subscribe("listMessages", maplit::btreemap!{
  ///     "channel".into() => 1.into(),
  /// }).await?;
  /// let sub2 = client.subscribe("listMessages", maplit::btreemap!{
  ///     "channel".into() => 1.into(),
  /// }).await?;
  /// # Ok(())
  /// # }
  Future<QuerySetSubscription> watchAll();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvexClientBuilder>>
abstract class ConvexClientBuilder implements RustOpaqueInterface {
  /// Build the [`ConvexClient`] with the configured options.
  ///
  /// ```no_run
  /// # use convex::ConvexClientBuilder;
  /// # #[tokio::main]
  /// # async fn main() -> anyhow::Result<()> {
  /// let client = ConvexClientBuilder::new("https://cool-music-123.convex.cloud").build().await?;
  /// # Ok(())
  /// # }
  /// ```
  Future<ConvexClient> build();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create a new [`ConvexClientBuilder`] with the given deployment URL.
  static Future<ConvexClientBuilder> newInstance({
    required String deploymentUrl,
  }) => RustLib.instance.api.convexConvexClientBuilderNew(
    deploymentUrl: deploymentUrl,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvexError>>
abstract class ConvexError implements RustOpaqueInterface {
  Value get data;

  String get message;

  set data(Value data);

  set message(String message);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>
abstract class Value implements RustOpaqueInterface {
  /// Converts this value to a JSON value in the `json` export format.
  /// <https://docs.convex.dev/database/types>
  ///
  /// It is possible for distinct Convex values to be serialized to the same
  /// JSON value by this method. For instance, strings and binary values are
  /// both exported as JSON strings. However, it is possible to convert the
  /// exported value back to a unique Convex value if you also have the `Type`
  /// value associated with the original Convex value (see `roundtrip.rs`).
  ///
  /// # Example
  /// ```
  /// use convex::Value;
  /// use serde_json::{
  ///     json,
  ///     Value as JsonValue,
  /// };
  ///
  /// let value = Value::Bytes(vec![0b00000000, 0b00010000, 0b10000011]);
  /// assert_eq!(JsonValue::from(value.clone()), json!({ "$bytes": "ABCD" }));
  /// assert_eq!(value.export(), json!("ABCD"));
  /// ```
  Future<JsonValue> export_();
}
